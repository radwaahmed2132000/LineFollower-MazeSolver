/*************
   Line Follower Robot
    Code Written by MYBOTIC
 *************/

#define mot1_speed 3
#define mot1_dir1 5
#define mot1_dir2 4

#define mot2_speed 6
#define mot2_dir1 8
#define mot2_dir2 7

int max_speed =  90 ; 

#define ncounts 90

int sensor1, sensor2, sensor3 , sensor4, sensor5;

float last_proportional = 0;
double  integral = 0;

void setup()
{

  pinMode(mot1_dir1, OUTPUT);
  pinMode(mot1_dir2, OUTPUT);
  pinMode(mot2_dir1, OUTPUT);
  pinMode(mot2_dir2, OUTPUT);


  Serial.begin(9600);



  pinMode(mot1_speed, OUTPUT);
  pinMode(mot2_speed, OUTPUT);

  digitalWrite(mot1_dir1, 1);
  digitalWrite(mot1_dir2, 0);
  digitalWrite(mot2_dir1, 1);
  digitalWrite(mot2_dir2, 0);

  analogWrite(mot1_speed, max_speed);
  analogWrite(mot2_speed, max_speed);
}

unsigned readLine( int *sensor_values)
{
  unsigned char i, on_line = 0;
  unsigned long avg; // this is for the weighted total, which is long
  // before division
  unsigned int sum; // this is for the denominator which is <= 64000
  static int last_value = 0; // assume initially that the line is left.
  const int _numSensors = 5;

  //readCalibrated(sensor_values, readMode);

  avg = 0;
  sum = 0;

  for (i = 0; i < _numSensors; i++) {
    int value = sensor_values[i];

    // keep track of whether we see the line at all
    if (value > 200) {
      on_line = 1;
    }

    // only average in values that are above a noise threshold
    if (value > 200) {
      avg += (long)(900) * (i * 1000);
      sum += 900;
    }

  }

  if (!on_line)
  {
    // If it last read to the left of center, return 0.
    if (last_value < (_numSensors - 1) * 1000 / 2)
      return 0;

    // If it last read to the right of center, return the max.
    else
      return (_numSensors - 1) * 1000/2.0;

  }

  last_value = avg / sum;

  return last_value/2.0;
}


void loop()
{
  max_speed =  80;
  sensor1 = analogRead(A0);
  sensor2 = analogRead(A4);
  sensor3 = analogRead(A1);
  sensor4 = analogRead(A3);
  sensor5 = analogRead(A2);

  int  arr[] = {sensor1, sensor2, sensor3, sensor4, sensor5};
  unsigned int position = readLine(arr);

 
    // The "proportional" term should be 0 when we are on the line.
    const int diff = 1000;
    float  proportional = (int)position - diff;


    // Compute the derivative (change) and integral (sum) of the
    // position.
    float  derivative = proportional - last_proportional;
    integral += proportional;

    // Remember the last position. 
    last_proportional = proportional;

    // Compute the difference between the two motor power settings,
    // m1 - m2.  If this is a positive number the robot will turn
    // to the right.  If it is a negative number, `the robot will
    // turn to the left, and the magnitude of the number determines
    // the sharpness of the turn.  You can adjust the constants by which
    // the proportional, integral, and derivative terms are multiplied to
    // improve performance.
    int power_difference = 1* proportional / 20 + integral*0/ 20000 + 0.75* derivative ;

    // Compute the actual motor settings.  We never set either motorderivae
    // to a negative value.
//    if (abs(proportional) > 170){
//    max_speed = 80;
//      }
//      
//    if (abs(proportional) > 400){
//        max_speed = 70;
//      }

    const int maximum = max_speed;
    if (power_difference > maximum)
      power_difference = maximum;
    if (power_difference < -maximum)
      power_difference = -maximum;

//    Serial.print("sensors: ");
//    Serial.print(sensor1);
//    Serial.print("  ");
//    Serial.print(sensor2);
//    Serial.print("  ");
//    Serial.print(sensor3);
//    Serial.print("  ");
//    Serial.print(sensor4);
//    Serial.print("  ");
//    Serial.print(sensor5);

    Serial.print(" p : ");
    Serial.print(proportional);
    Serial.print(" d : ");
    Serial.print(derivative );
    
    Serial.print("  position: ");
    Serial.print(position);
    Serial.print("  power diff ");
    Serial.print(power_difference);
    int base= 0;
//    if (proportional > 100 )
//    base = 0;
    if (power_difference < 0)
    {
      analogWrite(mot1_speed, maximum + power_difference+base);
      analogWrite(mot2_speed, maximum);
      
      Serial.print("  right: ");
      Serial.print(maximum + power_difference);
      Serial.print("  left:  ");
      Serial.println(maximum);

    }
    else
    {
      analogWrite(mot1_speed, maximum+base);
      analogWrite(mot2_speed, maximum - power_difference);

            Serial.print("right: ");
      Serial.print(maximum);
      Serial.print("  left:  ");
      Serial.println(maximum - power_difference);

    }
 
}